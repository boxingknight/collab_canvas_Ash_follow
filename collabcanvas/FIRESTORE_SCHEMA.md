# Firestore Schema Documentation

## Collections Structure

### `shapes` Collection

Each document represents a single shape on the canvas.

**Document ID:** Auto-generated by Firestore (unique ID)

**Fields:**

```typescript
{
  id: string;              // Firestore document ID (auto-generated)
  x: number;               // X coordinate (canvas position)
  y: number;               // Y coordinate (canvas position)
  width: number;           // Shape width in pixels
  height: number;          // Shape height in pixels
  color: string;           // Hex color code (e.g., "#646cff")
  createdBy: string;       // User UID from Firebase Auth
  createdAt: Timestamp;    // Firebase server timestamp
  updatedAt: Timestamp;    // Firebase server timestamp (for last modification)
  lockedBy: string | null; // User UID currently manipulating this shape (null if not locked)
  lockedAt: Timestamp | null; // Timestamp when lock was acquired (null if not locked)
}
```

**Example Document:**

```json
{
  "id": "abc123xyz789",
  "x": 150,
  "y": 200,
  "width": 100,
  "height": 80,
  "color": "#646cff",
  "createdBy": "user_uid_here",
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:35:00Z",
  "lockedBy": null,
  "lockedAt": null
}
```

**Example Document (Locked):**

```json
{
  "id": "abc123xyz789",
  "x": 150,
  "y": 200,
  "width": 100,
  "height": 80,
  "color": "#646cff",
  "createdBy": "user_uid_here",
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:35:00Z",
  "lockedBy": "another_user_uid",
  "lockedAt": "2024-01-15T10:36:00Z"
}
```

## Data Flow

### Creating a Shape

1. User draws shape on canvas (click-and-drag)
2. Shape created locally with temporary ID
3. Shape data sent to Firestore via `addShape()`
4. Firestore assigns document ID and server timestamp
5. Real-time listener receives the new shape
6. Local state updates with Firestore document ID

### Updating a Shape

1. User drags shape to new position
2. Shape is locked via `lockShape()` to prevent other users from manipulating it
3. Local state updates immediately (optimistic update)
4. Position sent to Firestore via `updateShape()`
5. Firestore updates document with new position and updatedAt timestamp
6. When drag ends, shape is unlocked via `unlockShape()`
7. Real-time listener broadcasts updates to other users

### Locking a Shape

1. User starts dragging a shape
2. `lockShape()` is called, setting `lockedBy` to the user's UID and `lockedAt` to current timestamp
3. Other users see a red lock icon on the shape
4. Other users cannot interact with or drag the locked shape
5. When dragging ends, `unlockShape()` is called, setting both fields to null
6. Stale locks (older than 30 seconds) are automatically cleaned up to handle disconnections

### Loading Shapes

1. Component mounts
2. Subscribe to shapes collection via `subscribeToShapes()`
3. Firestore returns all existing shapes
4. Shapes loaded into local state
5. Real-time updates continue via the same subscription

## Security Rules

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Shapes collection
    match /shapes/{shapeId} {
      // Allow authenticated users to read all shapes
      allow read: if request.auth != null;
      
      // Allow authenticated users to create shapes
      // Ensure createdBy matches the user's UID
      allow create: if request.auth != null 
                    && request.resource.data.createdBy == request.auth.uid;
      
      // Allow users to update any shape (collaborative editing)
      allow update: if request.auth != null;
      
      // Allow users to delete their own shapes only
      allow delete: if request.auth != null 
                    && resource.data.createdBy == request.auth.uid;
    }
  }
}
```

## Performance Considerations

### Indexing

Firestore automatically indexes by:
- `createdAt` - for chronological ordering
- `createdBy` - for filtering by user

### Query Limits

- Initial load: All shapes (no limit for MVP)
- Real-time updates: Continuous via snapshot listener

### Optimization Strategies (Future)

1. **Pagination:** Load shapes in batches for large canvases
2. **Viewport filtering:** Only load shapes visible in current viewport
3. **Debouncing:** Batch rapid position updates during dragging
4. **Offline support:** Use Firestore offline persistence

## Migration Path (Future Features)

### Version 2: Shape Types
Add `type` field: `"rectangle" | "circle" | "line" | "text"`

### Version 3: User Cursors
Add `cursors` collection for real-time cursor positions

### Version 4: Layers
Add `zIndex` field for stacking order

