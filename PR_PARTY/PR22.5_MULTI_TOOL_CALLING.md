# PR #22.5: Multi-Tool Calling (Chained AI Operations)

**Status**: 📋 Planned  
**Estimated Time**: 2-3 hours  
**Risk Level**: Low-Medium  
**Dependencies**: PR #22 (Layout Commands), PR #21 (Selection Commands), PR #18 (AI Service)

---

## 🎯 Overview

### Problem Statement

**Current Limitation**: AI can only execute ONE function per response, even when the user's intent clearly requires multiple steps.

**Examples of Broken Workflows**:
```
❌ "Arrange these horizontally then make them blue"
   → Only arranges, ignores color change

❌ "Select all rectangles and move them to the center"
   → Only selects, doesn't move

❌ "Create 3 circles and arrange them in a row"
   → Only creates, doesn't arrange
```

**Root Cause**: Our current implementation only processes the first `tool_call` from OpenAI's response, ignoring any subsequent function calls.

### Goal

Enable the AI to execute **multiple functions in a single response**, allowing natural chained operations like:

```
✅ "Select all rectangles and make them blue"
   → selectShapesByType('rectangle')
   → changeShapeColor([...], 'blue')

✅ "Create 3 circles and arrange them vertically"
   → createCircle(...)
   → createCircle(...)
   → createCircle(...)
   → arrangeVertical([id1, id2, id3], 20)

✅ "Arrange horizontally then center the group"
   → arrangeHorizontal([...], 20)
   → centerShapes([...])
```

### Why This Matters

1. **User Experience**: Natural language should support multi-step instructions
2. **AI Power**: Unlocks the full potential of GPT-4's function calling
3. **Efficiency**: One prompt accomplishes complex workflows
4. **Industry Standard**: Figma, v0, and other AI tools support chained operations
5. **Project Requirement**: Course mentions "complex operations" as a requirement

---

## 📋 Solution 1: Multi-Tool Calling (Industry Standard)

### Approach

Leverage OpenAI's **native multi-tool calling capability**. GPT-4 already supports returning multiple `tool_calls` in a single response - we just need to process all of them instead of only the first.

### How It Works

```javascript
// CURRENT BEHAVIOR (broken)
const response = await openai.chat.completions.create({
  messages: [...],
  tools: functionSchemas,
  tool_choice: 'auto'
});

const firstToolCall = response.choices[0].message.tool_calls[0]; // ❌ Only first
executeAIFunction(firstToolCall.function.name, firstToolCall.function.arguments);

// NEW BEHAVIOR (fixed)
const response = await openai.chat.completions.create({
  messages: [...],
  tools: functionSchemas,
  tool_choice: 'auto'
});

const allToolCalls = response.choices[0].message.tool_calls || []; // ✅ All of them
for (const toolCall of allToolCalls) {
  await executeAIFunction(toolCall.function.name, toolCall.function.arguments);
}
```

### Key Characteristics

- ✅ **Zero Prompt Engineering**: Relies on GPT-4's native capability
- ✅ **Sequential Execution**: Functions run in order (important for dependencies)
- ✅ **Error Resilient**: Can continue or stop on error (configurable)
- ✅ **Real-Time Feedback**: Each function result shown to user as it executes
- ✅ **Selection-Aware**: Later functions can use results from earlier ones
- ✅ **Multiplayer Safe**: Each operation syncs in real-time

---

## 🏗️ Architecture & Design

### Component Changes

#### 1. **ai.js** (OpenAI Service)
**File**: `collabcanvas/src/services/ai.js`

**Current Code** (~line 280):
```javascript
export async function sendMessage(messages, canvasState, selection) {
  try {
    const response = await openai.chat.completions.create({
      model: AI_MODEL,
      messages: formattedMessages,
      tools: functionSchemas,
      tool_choice: 'auto',
      temperature: 0.7,
    });

    const message = response.choices[0].message;

    // ❌ Only processes first tool call
    if (message.tool_calls && message.tool_calls.length > 0) {
      const toolCall = message.tool_calls[0];
      const functionName = toolCall.function.name;
      const functionArgs = JSON.parse(toolCall.function.arguments);
      
      const result = await executeAIFunction(functionName, functionArgs);
      
      return {
        type: 'function',
        content: message.content || '',
        functionName,
        functionArgs,
        result
      };
    }
    
    return {
      type: 'text',
      content: message.content
    };
  } catch (error) {
    // ... error handling
  }
}
```

**New Code** (Multi-Tool Calling):
```javascript
export async function sendMessage(messages, canvasState, selection) {
  try {
    const response = await openai.chat.completions.create({
      model: AI_MODEL,
      messages: formattedMessages,
      tools: functionSchemas,
      tool_choice: 'auto',
      temperature: 0.7,
    });

    const message = response.choices[0].message;

    // ✅ Process ALL tool calls
    if (message.tool_calls && message.tool_calls.length > 0) {
      const results = [];
      
      for (const toolCall of message.tool_calls) {
        const functionName = toolCall.function.name;
        let functionArgs;
        
        try {
          functionArgs = JSON.parse(toolCall.function.arguments);
        } catch (parseError) {
          console.error('[AI] Failed to parse function arguments:', parseError);
          results.push({
            functionName,
            functionArgs: {},
            result: { 
              success: false, 
              error: 'INVALID_ARGUMENTS',
              userMessage: 'Failed to parse function arguments'
            }
          });
          continue; // Skip this function, continue with others
        }
        
        console.log(`[AI] Executing function ${results.length + 1}/${message.tool_calls.length}:`, functionName);
        
        const result = await executeAIFunction(functionName, functionArgs);
        
        results.push({
          functionName,
          functionArgs,
          result
        });
        
        // Stop execution if critical function fails
        if (!result.success && shouldStopOnError(functionName)) {
          console.warn('[AI] Critical function failed, stopping execution chain');
          break;
        }
      }
      
      return {
        type: 'function_chain', // New type for multiple functions
        content: message.content || '',
        executionCount: results.length,
        totalCalls: message.tool_calls.length,
        results // Array of all function results
      };
    }
    
    // Backwards compatibility: single function call
    // (Keep this for debugging/testing)
    if (message.tool_calls && message.tool_calls.length === 1) {
      const toolCall = message.tool_calls[0];
      const functionName = toolCall.function.name;
      const functionArgs = JSON.parse(toolCall.function.arguments);
      const result = await executeAIFunction(functionName, functionArgs);
      
      return {
        type: 'function',
        content: message.content || '',
        functionName,
        functionArgs,
        result
      };
    }
    
    return {
      type: 'text',
      content: message.content
    };
  } catch (error) {
    // ... error handling
  }
}

/**
 * Determines if execution should stop when this function fails
 * @param {string} functionName - Name of the failed function
 * @returns {boolean} True if execution should stop
 */
function shouldStopOnError(functionName) {
  // Critical functions that should stop execution chain if they fail
  const criticalFunctions = [
    'getSelectedShapes',  // If selection fails, later ops might be invalid
    'selectShapesByType', // Same - selection is often prerequisite
    'selectShapesByColor',
    'selectShapesInRegion'
  ];
  
  return criticalFunctions.includes(functionName);
}
```

**Key Changes**:
1. Loop through ALL `tool_calls` instead of just `[0]`
2. Return new `type: 'function_chain'` with array of results
3. Add error handling per function (continue or stop)
4. Add execution progress logging
5. Maintain backwards compatibility for single function calls

---

#### 2. **useAI.js** (React Hook)
**File**: `collabcanvas/src/hooks/useAI.js`

**Current Code** (~line 120):
```javascript
const handleSend = async (content) => {
  if (!content.trim()) return;

  const userMessage = { role: 'user', content };
  setMessages(prev => [...prev, userMessage]);
  setInput('');
  setIsLoading(true);

  try {
    const response = await sendMessage(
      [...messages, userMessage],
      canvasState,
      selection
    );

    // ❌ Only handles single function result
    const assistantMessage = {
      role: 'assistant',
      content: response.content || 'Done!',
      type: response.type,
      functionName: response.functionName,
      functionArgs: response.functionArgs,
      result: response.result
    };

    setMessages(prev => [...prev, assistantMessage]);
  } catch (error) {
    // ... error handling
  } finally {
    setIsLoading(false);
  }
};
```

**New Code** (Multi-Tool Support):
```javascript
const handleSend = async (content) => {
  if (!content.trim()) return;

  const userMessage = { role: 'user', content };
  setMessages(prev => [...prev, userMessage]);
  setInput('');
  setIsLoading(true);

  try {
    const response = await sendMessage(
      [...messages, userMessage],
      canvasState,
      selection
    );

    // ✅ Handle both single and multi-function responses
    let assistantMessage;
    
    if (response.type === 'function_chain') {
      // Multi-function response
      assistantMessage = {
        role: 'assistant',
        content: response.content || `Executed ${response.executionCount} operations`,
        type: 'function_chain',
        executionCount: response.executionCount,
        totalCalls: response.totalCalls,
        results: response.results, // Array of function results
        timestamp: Date.now()
      };
    } else if (response.type === 'function') {
      // Single function response (backwards compatible)
      assistantMessage = {
        role: 'assistant',
        content: response.content || 'Done!',
        type: 'function',
        functionName: response.functionName,
        functionArgs: response.functionArgs,
        result: response.result,
        timestamp: Date.now()
      };
    } else {
      // Text-only response
      assistantMessage = {
        role: 'assistant',
        content: response.content,
        type: 'text',
        timestamp: Date.now()
      };
    }

    setMessages(prev => [...prev, assistantMessage]);
  } catch (error) {
    // ... error handling
  } finally {
    setIsLoading(false);
  }
};
```

**Key Changes**:
1. Check for `function_chain` type
2. Store array of results instead of single result
3. Add execution counts for UI display
4. Maintain backwards compatibility

---

#### 3. **ChatMessage.jsx** (UI Component)
**File**: `collabcanvas/src/components/AI/ChatMessage.jsx`

**Current Code**:
```javascript
function ChatMessage({ message }) {
  if (message.type === 'function') {
    return (
      <div className="message assistant">
        <div className="message-content">
          <strong>✓ {message.functionName}</strong>
          <pre>{JSON.stringify(message.functionArgs, null, 2)}</pre>
          {message.result.userMessage && (
            <div className="result">{message.result.userMessage}</div>
          )}
        </div>
      </div>
    );
  }
  
  return (
    <div className={`message ${message.role}`}>
      <div className="message-content">{message.content}</div>
    </div>
  );
}
```

**New Code** (Multi-Function Display):
```javascript
function ChatMessage({ message }) {
  // Multi-function chain
  if (message.type === 'function_chain') {
    return (
      <div className="message assistant function-chain">
        <div className="message-content">
          {message.content && (
            <div className="chain-header">{message.content}</div>
          )}
          
          <div className="chain-summary">
            Executed {message.executionCount} of {message.totalCalls} operations
          </div>
          
          <div className="chain-operations">
            {message.results.map((operation, index) => (
              <div 
                key={index} 
                className={`operation ${operation.result.success ? 'success' : 'error'}`}
              >
                <div className="operation-header">
                  <span className="operation-number">{index + 1}.</span>
                  <strong>{operation.functionName}</strong>
                  {operation.result.success ? (
                    <span className="status-icon">✓</span>
                  ) : (
                    <span className="status-icon error">✗</span>
                  )}
                </div>
                
                {/* Show user-friendly message */}
                {operation.result.userMessage && (
                  <div className="operation-result">
                    {operation.result.userMessage}
                  </div>
                )}
                
                {/* Show error if failed */}
                {!operation.result.success && operation.result.error && (
                  <div className="operation-error">
                    Error: {operation.result.error}
                  </div>
                )}
                
                {/* Collapsible details */}
                <details className="operation-details">
                  <summary>View details</summary>
                  <pre>{JSON.stringify(operation.functionArgs, null, 2)}</pre>
                </details>
              </div>
            ))}
          </div>
        </div>
      </div>
    );
  }
  
  // Single function (backwards compatible)
  if (message.type === 'function') {
    return (
      <div className="message assistant">
        <div className="message-content">
          <strong>✓ {message.functionName}</strong>
          <pre>{JSON.stringify(message.functionArgs, null, 2)}</pre>
          {message.result.userMessage && (
            <div className="result">{message.result.userMessage}</div>
          )}
        </div>
      </div>
    );
  }
  
  // Text message
  return (
    <div className={`message ${message.role}`}>
      <div className="message-content">{message.content}</div>
    </div>
  );
}
```

**Key Changes**:
1. Add `function_chain` rendering
2. Display execution summary (X of Y operations)
3. Show each operation with success/error status
4. Collapsible details for each function
5. Maintain backwards compatibility

---

#### 4. **ChatMessage.css** (Styling)
**File**: `collabcanvas/src/components/AI/ChatMessage.css`

**New Styles**:
```css
/* Multi-function chain styles */
.message.function-chain {
  background: linear-gradient(135deg, #2d2d3f 0%, #1e1e2e 100%);
  border-left: 4px solid #646cff;
}

.chain-header {
  font-weight: 600;
  margin-bottom: 12px;
  color: #fff;
}

.chain-summary {
  font-size: 0.9em;
  color: #a0a0b0;
  margin-bottom: 16px;
  padding: 8px 12px;
  background: rgba(100, 108, 255, 0.1);
  border-radius: 6px;
  display: inline-block;
}

.chain-operations {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.operation {
  background: rgba(255, 255, 255, 0.05);
  padding: 12px;
  border-radius: 8px;
  border-left: 3px solid #646cff;
  transition: all 0.2s ease;
}

.operation:hover {
  background: rgba(255, 255, 255, 0.08);
}

.operation.error {
  border-left-color: #ff6b6b;
}

.operation-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.operation-number {
  color: #646cff;
  font-weight: 700;
  font-size: 0.9em;
  min-width: 20px;
}

.operation-header strong {
  flex: 1;
  color: #fff;
  font-family: 'Courier New', monospace;
  font-size: 0.95em;
}

.status-icon {
  color: #4caf50;
  font-size: 1.2em;
  font-weight: bold;
}

.status-icon.error {
  color: #ff6b6b;
}

.operation-result {
  color: #c0c0d0;
  font-size: 0.9em;
  padding: 8px 12px;
  background: rgba(100, 108, 255, 0.1);
  border-radius: 6px;
  margin-top: 8px;
}

.operation-error {
  color: #ff6b6b;
  font-size: 0.85em;
  padding: 6px 10px;
  background: rgba(255, 107, 107, 0.1);
  border-radius: 4px;
  margin-top: 6px;
  font-family: 'Courier New', monospace;
}

.operation-details {
  margin-top: 8px;
}

.operation-details summary {
  cursor: pointer;
  color: #646cff;
  font-size: 0.85em;
  user-select: none;
  padding: 4px 0;
}

.operation-details summary:hover {
  color: #7d85ff;
}

.operation-details pre {
  margin-top: 8px;
  padding: 8px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  font-size: 0.8em;
  overflow-x: auto;
}
```

---

## 🧪 Testing Strategy

### Manual Test Cases

#### Test 1: Two-Step Operation
**Command**: "Select all rectangles and make them blue"

**Expected Behavior**:
1. AI returns TWO tool calls:
   - `selectShapesByType('rectangle')`
   - `changeShapeColor([...ids], 'blue')`
2. Both execute sequentially
3. UI shows 2 operations
4. All rectangles turn blue
5. Real-time sync to other users

**Success Criteria**:
- ✅ Both functions execute
- ✅ UI shows "Executed 2 of 2 operations"
- ✅ Each operation has success checkmark
- ✅ Canvas updates correctly

---

#### Test 2: Three-Step Creation + Layout
**Command**: "Create 3 circles and arrange them horizontally"

**Expected Behavior**:
1. AI returns FOUR tool calls:
   - `createCircle(...)` [circle 1]
   - `createCircle(...)` [circle 2]
   - `createCircle(...)` [circle 3]
   - `arrangeHorizontal([id1, id2, id3], 20)`
2. All execute in order
3. 3 circles created
4. Circles arranged in row
5. Real-time sync

**Success Criteria**:
- ✅ 4 operations execute
- ✅ 3 circles appear on canvas
- ✅ Circles are in horizontal row
- ✅ Spacing is correct (~20px)

---

#### Test 3: Selection + Manipulation + Layout
**Command**: "Select all shapes in top-left, move them 100px right, and center them"

**Expected Behavior**:
1. AI returns THREE tool calls:
   - `selectShapesInRegion(0, 0, 1250, 1250)`
   - `moveShape([...ids], 100, 0)` [relative move]
   - `centerShapes([...ids])`
2. All execute
3. Shapes selected, moved, then centered

**Success Criteria**:
- ✅ 3 operations execute
- ✅ Correct shapes selected
- ✅ Shapes move right 100px
- ✅ Final position is centered

---

#### Test 4: Error Handling (Partial Failure)
**Command**: "Select all triangles and make them red"

**Expected Behavior**:
1. AI returns TWO tool calls:
   - `selectShapesByType('triangle')` [will fail - no triangles]
   - `changeShapeColor([...], 'red')` [should not execute]
2. First operation fails
3. Second operation skipped (critical function failed)
4. UI shows error clearly

**Success Criteria**:
- ✅ Execution stops after first failure
- ✅ UI shows "Executed 1 of 2 operations"
- ✅ Error message is clear
- ✅ Canvas unchanged

---

#### Test 5: Complex Workflow (5+ Operations)
**Command**: "Create a 2x2 grid of rectangles, select them all, make them blue, and arrange them in a horizontal row"

**Expected Behavior**:
1. AI returns 7 tool calls:
   - `createRectangle(...)` x4
   - `selectShapes([id1, id2, id3, id4])`
   - `changeShapeColor([...], 'blue')`
   - `arrangeHorizontal([...], 30)`
2. All execute successfully
3. Final result: 4 blue rectangles in a row

**Success Criteria**:
- ✅ All 7 operations execute
- ✅ 4 rectangles created
- ✅ All blue
- ✅ Arranged horizontally
- ✅ UI shows all 7 steps

---

### Performance Test Cases

#### Test 6: Many Operations (10+)
**Command**: "Create 10 random shapes"

**Expected**:
- 10 function calls
- All execute within 5 seconds
- UI remains responsive
- No lag

---

#### Test 7: Rapid Chained Commands
**Action**: Send 3 chained commands rapidly (without waiting for completion)

**Expected**:
- All commands execute in order
- No race conditions
- UI shows all results
- Canvas state consistent

---

## 📊 Success Criteria

### Must Have (Required)
- ✅ AI can execute 2+ functions in a single response
- ✅ Functions execute in sequential order
- ✅ UI displays all function results clearly
- ✅ Error handling stops critical failures
- ✅ Real-time sync works for all operations
- ✅ Backwards compatible with single function calls
- ✅ Works with all 23 existing AI functions

### Nice to Have (Optional)
- 🎯 Execution progress indicator (1 of 5, 2 of 5...)
- 🎯 Ability to retry failed operations
- 🎯 Parallel execution for independent operations
- 🎯 Undo entire chain with one command

### Out of Scope
- ❌ Parallel execution (all operations are sequential)
- ❌ Conditional logic between functions
- ❌ Loops or recursive function calling
- ❌ User intervention mid-execution

---

## 🚧 Implementation Rollout

### Phase 1: Core Multi-Tool Execution (1 hour)
1. Modify `ai.js` to loop through all `tool_calls`
2. Update return type to `function_chain`
3. Add `shouldStopOnError()` helper
4. Test with 2-function commands

**Checkpoint**: Can execute 2 functions in sequence

---

### Phase 2: React Hook Updates (30 minutes)
1. Update `useAI.js` to handle `function_chain` type
2. Store array of results in message
3. Add execution counts
4. Test with multiple commands

**Checkpoint**: Hook stores and passes multi-function data correctly

---

### Phase 3: UI Display (45 minutes)
1. Update `ChatMessage.jsx` to render chains
2. Add CSS styling for multi-function display
3. Add collapsible details
4. Add success/error indicators

**Checkpoint**: UI clearly shows all operations and results

---

### Phase 4: Testing & Polish (30 minutes)
1. Run all 7 test cases
2. Fix any bugs
3. Test edge cases
4. Verify multiplayer sync

**Checkpoint**: All test cases pass

---

## ⚠️ Risk Assessment

### Technical Risks

#### Risk 1: OpenAI Doesn't Always Return Multiple Tool Calls
**Probability**: Medium  
**Impact**: High  
**Mitigation**: 
- GPT-4 is designed for this - test with explicit multi-step prompts
- If it doesn't work, we can add prompt engineering
- Fallback to current behavior (single function)

#### Risk 2: Sequential Execution Too Slow
**Probability**: Low  
**Impact**: Medium  
**Mitigation**:
- Most operations complete in <500ms
- UI shows progress so user knows it's working
- Can optimize to parallel execution later if needed

#### Risk 3: Error Handling Complexity
**Probability**: Medium  
**Impact**: Medium  
**Mitigation**:
- Clear `shouldStopOnError()` logic
- Each function already has error handling
- UI clearly shows which operation failed

---

### Project Risks

#### Risk 1: Scope Creep
**Probability**: Medium  
**Impact**: Low  
**Mitigation**:
- Stick to planned 3-phase rollout
- Don't add parallel execution or advanced features
- Keep it simple

#### Risk 2: Breaking Existing Functionality
**Probability**: Low  
**Impact**: High  
**Mitigation**:
- Maintain backwards compatibility
- Keep single-function path intact
- Test all existing commands

---

## 📈 Expected Impact

### User Experience
- ✅ Natural multi-step commands work
- ✅ Complex workflows in one prompt
- ✅ Clear feedback on each step
- ✅ Fewer back-and-forth messages

### Project Completion
- ✅ Meets "complex operations" requirement
- ✅ Demonstrates AI sophistication
- ✅ Shows industry-standard implementation
- ✅ Competitive with Figma/v0

### Technical Quality
- ✅ Clean, maintainable code
- ✅ Backwards compatible
- ✅ Well-tested
- ✅ Production-ready

---

## 🔗 Related Documentation

- **PR #22**: [AI Layout Commands](PR22_LAYOUT_COMMANDS.md) - Functions we're chaining
- **PR #21**: [AI Selection Commands](PR21_SELECTION_COMMANDS.md) - Selection functions
- **PR #18**: [AI Service Integration](archive/PR18_AI_SERVICE_INTEGRATION.md) - Core AI service
- **AI Features Summary**: [AI_FEATURES_SUMMARY.md](../AI_FEATURES_SUMMARY.md) - Complete function list

---

## 🎯 Definition of Done

- [ ] Multi-tool calling implemented in `ai.js`
- [ ] `useAI.js` handles `function_chain` type
- [ ] `ChatMessage.jsx` renders multi-function results
- [ ] CSS styling complete and polished
- [ ] All 7 test cases pass
- [ ] No linter errors
- [ ] No breaking changes to existing functionality
- [ ] Documentation complete
- [ ] Code committed and pushed
- [ ] Production deployment successful

---

## 📝 Notes for Implementation

### Key Insights
1. **OpenAI Already Supports This**: We're just enabling a feature that exists
2. **Sequential is Correct**: Functions often depend on earlier results (e.g., selection → manipulation)
3. **Error Handling is Critical**: Need clear logic for when to stop vs. continue
4. **UI Feedback is Essential**: User needs to see progress through multi-step operations

### Common Pitfalls to Avoid
- ❌ Don't try to parallelize execution (breaks dependencies)
- ❌ Don't over-complicate error handling (keep it simple)
- ❌ Don't break backwards compatibility (single functions must still work)
- ❌ Don't forget multiplayer sync (each operation must broadcast)

### Testing Philosophy
- Test happy path first (2-3 functions working together)
- Test error cases second (partial failures)
- Test complex scenarios last (5+ functions)
- Always test multiplayer sync

---

**Ready to implement!** 🚀

This is a **2-3 hour task** that unlocks **massive value** for the AI assistant. Let's make CollabCanvas truly intelligent!

